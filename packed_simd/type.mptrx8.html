<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `mptrx8` type in crate `packed_simd`."><meta name="keywords" content="rust, rustlang, rust-lang, mptrx8"><title>packed_simd::mptrx8 - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script></head><body class="rustdoc type"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Type Definition mptrx8</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#methods">Methods</a><div class="sidebar-links"><a href="#method.new">new</a><a href="#method.lanes">lanes</a><a href="#method.splat">splat</a><a href="#method.null">null</a><a href="#method.is_null">is_null</a><a href="#method.extract">extract</a><a href="#method.extract_unchecked">extract_unchecked</a><a href="#method.replace">replace</a><a href="#method.replace_unchecked">replace_unchecked</a><a href="#method.eq">eq</a><a href="#method.ne">ne</a><a href="#method.lt">lt</a><a href="#method.le">le</a><a href="#method.gt">gt</a><a href="#method.ge">ge</a><a href="#method.from_slice_aligned">from_slice_aligned</a><a href="#method.from_slice_unaligned">from_slice_unaligned</a><a href="#method.from_slice_aligned_unchecked">from_slice_aligned_unchecked</a><a href="#method.from_slice_unaligned_unchecked">from_slice_unaligned_unchecked</a><a href="#method.write_to_slice_aligned">write_to_slice_aligned</a><a href="#method.write_to_slice_unaligned">write_to_slice_unaligned</a><a href="#method.write_to_slice_aligned_unchecked">write_to_slice_aligned_unchecked</a><a href="#method.write_to_slice_unaligned_unchecked">write_to_slice_unaligned_unchecked</a><a href="#method.offset">offset</a><a href="#method.wrapping_offset">wrapping_offset</a><a href="#method.offset_from">offset_from</a><a href="#method.wrapping_offset_from">wrapping_offset_from</a><a href="#method.add">add</a><a href="#method.sub">sub</a><a href="#method.wrapping_add">wrapping_add</a><a href="#method.wrapping_sub">wrapping_sub</a><a href="#method.read">read</a><a href="#method.write">write</a></div><a class="sidebar-title" href="#implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Debug">Debug</a><a href="#impl-Default">Default</a><a href="#impl-PartialEq%3Cmptrx8%3CT%3E%3E">PartialEq&lt;mptrx8&lt;T&gt;&gt;</a><a href="#impl-Eq">Eq</a><a href="#impl-From%3C%5B*mut%20T%3B%208%5D%3E">From&lt;[*mut T; 8]&gt;</a><a href="#impl-Into%3C%5B*mut%20T%3B%208%5D%3E">Into&lt;[*mut T; 8]&gt;</a><a href="#impl-Hash">Hash</a></div></div><p class='location'><a href='index.html'>packed_simd</a></p><script>window.sidebarCurrent = {name: 'mptrx8', ty: 'type', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#9' title='goto source code'>[src]</a></span><span class='in-band'>Type Definition <a href='index.html'>packed_simd</a>::<wbr><a class="type" href=''>mptrx8</a></span></h1><pre class='rust typedef'>type mptrx8&lt;T&gt; = <a class="struct" href="../packed_simd/struct.Simd.html" title="struct packed_simd::Simd">Simd</a>&lt;[*mut T; 8]&gt;;</pre><div class='docblock'><p>A vector with 8 <code>*mut T</code> lanes</p>
</div><h2 id='methods' class='small-section-header'>Methods<a href='#methods' class='anchor'></a></h2><h3 id='impl' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="type" href="../packed_simd/type.mptrx8.html" title="type packed_simd::mptrx8">mptrx8</a>&lt;T&gt;</code><a href='#impl' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#17-105' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.new' class="method"><span id='new.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub const fn <a href='#method.new' class='fnname'>new</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;x0: *mut T, <br>&nbsp;&nbsp;&nbsp;&nbsp;x1: *mut T, <br>&nbsp;&nbsp;&nbsp;&nbsp;x2: *mut T, <br>&nbsp;&nbsp;&nbsp;&nbsp;x3: *mut T, <br>&nbsp;&nbsp;&nbsp;&nbsp;x4: *mut T, <br>&nbsp;&nbsp;&nbsp;&nbsp;x5: *mut T, <br>&nbsp;&nbsp;&nbsp;&nbsp;x6: *mut T, <br>&nbsp;&nbsp;&nbsp;&nbsp;x7: *mut T<br>) -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#22-24' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Creates a new instance with each vector elements initialized
with the provided values.</p>
</div><h4 id='method.lanes' class="method"><span id='lanes.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub const fn <a href='#method.lanes' class='fnname'>lanes</a>() -&gt; usize</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#28-30' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns the number of vector lanes.</p>
</div><h4 id='method.splat' class="method"><span id='splat.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub const fn <a href='#method.splat' class='fnname'>splat</a>(value: *mut T) -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#35-41' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Constructs a new instance with each element initialized to
<code>value</code>.</p>
</div><h4 id='method.null' class="method"><span id='null.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub const fn <a href='#method.null' class='fnname'>null</a>() -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#45-47' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Constructs a new instance with each element initialized to <code>null</code>.</p>
</div><h4 id='method.is_null' class="method"><span id='is_null.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.is_null' class='fnname'>is_null</a>(self) -&gt; <a class="type" href="../packed_simd/type.msizex8.html" title="type packed_simd::msizex8">msizex8</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#51-53' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a mask that selects those lanes that contain <code>null</code> pointers.</p>
</div><h4 id='method.extract' class="method"><span id='extract.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.extract' class='fnname'>extract</a>(self, index: usize) -&gt; *mut T</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#61-64' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Extracts the value at <code>index</code>.</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>If <code>index &gt;= Self::lanes()</code>.</p>
</div><h4 id='method.extract_unchecked' class="method"><span id='extract_unchecked.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub unsafe fn <a href='#method.extract_unchecked' class='fnname'>extract_unchecked</a>(self, index: usize) -&gt; *mut T</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#72-75' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Extracts the value at <code>index</code>.</p>
<h1 id="precondition" class="section-header"><a href="#precondition">Precondition</a></h1>
<p>If <code>index &gt;= Self::lanes()</code> the behavior is undefined.</p>
</div><h4 id='method.replace' class="method"><span id='replace.v' class='invisible'><table class='table-display'><tbody><tr><td><code><div class="docblock attributes">#[must_use = "replace does not modify the original value - it returns a new vector with the value at `index` replaced by `new_value`d"]
</div>pub fn <a href='#method.replace' class='fnname'>replace</a>(self, index: usize, new_value: *mut T) -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#85-88' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a new vector where the value at <code>index</code> is replaced by <code>new_value</code>.</p>
<h1 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h1>
<p>If <code>index &gt;= Self::lanes()</code>.</p>
</div><h4 id='method.replace_unchecked' class="method"><span id='replace_unchecked.v' class='invisible'><table class='table-display'><tbody><tr><td><code><div class="docblock attributes">#[must_use = "replace_unchecked does not modify the original value - it returns a new vector with the value at `index` replaced by `new_value`d"]
</div>pub unsafe fn <a href='#method.replace_unchecked' class='fnname'>replace_unchecked</a>(self, index: usize, new_value: *mut T) -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#97-104' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a new vector where the value at <code>index</code> is replaced by <code>new_value</code>.</p>
<h1 id="precondition-1" class="section-header"><a href="#precondition-1">Precondition</a></h1>
<p>If <code>index &gt;= Self::lanes()</code> the behavior is undefined.</p>
</div></div><h3 id='impl-1' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="type" href="../packed_simd/type.mptrx8.html" title="type packed_simd::mptrx8">mptrx8</a>&lt;T&gt;</code><a href='#impl-1' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#261-327' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.eq' class="method"><span id='eq.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.eq' class='fnname'>eq</a>(self, other: Self) -&gt; <a class="type" href="../packed_simd/type.msizex8.html" title="type packed_simd::msizex8">msizex8</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#264-271' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Lane-wise equality comparison.</p>
</div><h4 id='method.ne' class="method"><span id='ne.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.ne' class='fnname'>ne</a>(self, other: Self) -&gt; <a class="type" href="../packed_simd/type.msizex8.html" title="type packed_simd::msizex8">msizex8</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#275-282' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Lane-wise inequality comparison.</p>
</div><h4 id='method.lt' class="method"><span id='lt.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.lt' class='fnname'>lt</a>(self, other: Self) -&gt; <a class="type" href="../packed_simd/type.msizex8.html" title="type packed_simd::msizex8">msizex8</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#286-293' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Lane-wise less-than comparison.</p>
</div><h4 id='method.le' class="method"><span id='le.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.le' class='fnname'>le</a>(self, other: Self) -&gt; <a class="type" href="../packed_simd/type.msizex8.html" title="type packed_simd::msizex8">msizex8</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#297-304' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Lane-wise less-than-or-equals comparison.</p>
</div><h4 id='method.gt' class="method"><span id='gt.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.gt' class='fnname'>gt</a>(self, other: Self) -&gt; <a class="type" href="../packed_simd/type.msizex8.html" title="type packed_simd::msizex8">msizex8</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#308-315' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Lane-wise greater-than comparison.</p>
</div><h4 id='method.ge' class="method"><span id='ge.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.ge' class='fnname'>ge</a>(self, other: Self) -&gt; <a class="type" href="../packed_simd/type.msizex8.html" title="type packed_simd::msizex8">msizex8</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#319-326' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Lane-wise greater-than-or-equals comparison.</p>
</div></div><h3 id='impl-2' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="type" href="../packed_simd/type.mptrx8.html" title="type packed_simd::mptrx8">mptrx8</a>&lt;T&gt;</code><a href='#impl-2' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#514-580' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.from_slice_aligned' class="method"><span id='from_slice_aligned.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.from_slice_aligned' class='fnname'>from_slice_aligned</a>(slice: &amp;[*mut T]) -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#522-532' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Instantiates a new vector with the values of the <code>slice</code>.</p>
<h1 id="panics-2" class="section-header"><a href="#panics-2">Panics</a></h1>
<p>If <code>slice.len() &lt; Self::lanes()</code> or <code>&amp;slice[0]</code> is not aligned
to an <code>align_of::&lt;Self&gt;()</code> boundary.</p>
</div><h4 id='method.from_slice_unaligned' class="method"><span id='from_slice_unaligned.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.from_slice_unaligned' class='fnname'>from_slice_unaligned</a>(slice: &amp;[*mut T]) -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#540-545' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Instantiates a new vector with the values of the <code>slice</code>.</p>
<h1 id="panics-3" class="section-header"><a href="#panics-3">Panics</a></h1>
<p>If <code>slice.len() &lt; Self::lanes()</code>.</p>
</div><h4 id='method.from_slice_aligned_unchecked' class="method"><span id='from_slice_aligned_unchecked.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub unsafe fn <a href='#method.from_slice_aligned_unchecked' class='fnname'>from_slice_aligned_unchecked</a>(slice: &amp;[*mut T]) -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#554-557' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Instantiates a new vector with the values of the <code>slice</code>.</p>
<h1 id="precondition-2" class="section-header"><a href="#precondition-2">Precondition</a></h1>
<p>If <code>slice.len() &lt; Self::lanes()</code> or <code>&amp;slice[0]</code> is not aligned
to an <code>align_of::&lt;Self&gt;()</code> boundary, the behavior is undefined.</p>
</div><h4 id='method.from_slice_unaligned_unchecked' class="method"><span id='from_slice_unaligned_unchecked.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub unsafe fn <a href='#method.from_slice_unaligned_unchecked' class='fnname'>from_slice_unaligned_unchecked</a>(slice: &amp;[*mut T]) -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#565-579' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Instantiates a new vector with the values of the <code>slice</code>.</p>
<h1 id="precondition-3" class="section-header"><a href="#precondition-3">Precondition</a></h1>
<p>If <code>slice.len() &lt; Self::lanes()</code> the behavior is undefined.</p>
</div></div><h3 id='impl-3' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="type" href="../packed_simd/type.mptrx8.html" title="type packed_simd::mptrx8">mptrx8</a>&lt;T&gt;</code><a href='#impl-3' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#699-767' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.write_to_slice_aligned' class="method"><span id='write_to_slice_aligned.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.write_to_slice_aligned' class='fnname'>write_to_slice_aligned</a>(self, slice: &amp;mut [*mut T])</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#707-718' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Writes the values of the vector to the <code>slice</code>.</p>
<h1 id="panics-4" class="section-header"><a href="#panics-4">Panics</a></h1>
<p>If <code>slice.len() &lt; Self::lanes()</code> or <code>&amp;slice[0]</code> is not
aligned to an <code>align_of::&lt;Self&gt;()</code> boundary.</p>
</div><h4 id='method.write_to_slice_unaligned' class="method"><span id='write_to_slice_unaligned.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.write_to_slice_unaligned' class='fnname'>write_to_slice_unaligned</a>(self, slice: &amp;mut [*mut T])</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#726-731' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Writes the values of the vector to the <code>slice</code>.</p>
<h1 id="panics-5" class="section-header"><a href="#panics-5">Panics</a></h1>
<p>If <code>slice.len() &lt; Self::lanes()</code>.</p>
</div><h4 id='method.write_to_slice_aligned_unchecked' class="method"><span id='write_to_slice_aligned_unchecked.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub unsafe fn <a href='#method.write_to_slice_aligned_unchecked' class='fnname'>write_to_slice_aligned_unchecked</a>(self, slice: &amp;mut [*mut T])</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#741-747' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Writes the values of the vector to the <code>slice</code>.</p>
<h1 id="precondition-4" class="section-header"><a href="#precondition-4">Precondition</a></h1>
<p>If <code>slice.len() &lt; Self::lanes()</code> or <code>&amp;slice[0]</code> is not
aligned to an <code>align_of::&lt;Self&gt;()</code> boundary, the behavior is
undefined.</p>
</div><h4 id='method.write_to_slice_unaligned_unchecked' class="method"><span id='write_to_slice_unaligned_unchecked.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub unsafe fn <a href='#method.write_to_slice_unaligned_unchecked' class='fnname'>write_to_slice_unaligned_unchecked</a>(self, slice: &amp;mut [*mut T])</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#755-766' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Writes the values of the vector to the <code>slice</code>.</p>
<h1 id="precondition-5" class="section-header"><a href="#precondition-5">Precondition</a></h1>
<p>If <code>slice.len() &lt; Self::lanes()</code> the behavior is undefined.</p>
</div></div><h3 id='impl-4' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="type" href="../packed_simd/type.mptrx8.html" title="type packed_simd::mptrx8">mptrx8</a>&lt;T&gt;</code><a href='#impl-4' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#923-1177' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.offset' class="method"><span id='offset.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub unsafe fn <a href='#method.offset' class='fnname'>offset</a>(self, count: <a class="type" href="../packed_simd/type.isizex8.html" title="type packed_simd::isizex8">isizex8</a>) -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#962-965' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Calculates the offset from a pointer.</p>
<p><code>count</code> is in units of <code>T</code>; e.g. a count of <code>3</code> represents a
pointer offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>If any of the following conditions are violated, the result is
Undefined Behavior:</p>
<ul>
<li>
<p>Both the starting and resulting pointer must be either in bounds
or one byte past the end of an allocated object.</p>
</li>
<li>
<p>The computed offset, in bytes, cannot overflow an <code>isize</code>.</p>
</li>
<li>
<p>The offset being in bounds cannot rely on &quot;wrapping around&quot; the
address space. That is, the infinite-precision sum, in bytes
must fit in a <code>usize</code>.</p>
</li>
</ul>
<p>The compiler and standard library generally tries to ensure
allocations never reach a size where an offset is a concern. For
instance, <code>Vec</code> and <code>Box</code> ensure they never allocate more than
<code>isize::MAX</code> bytes, so <code>vec.as_ptr().offset(vec.len() as isize)</code> is
always safe.</p>
<p>Most platforms fundamentally can't even construct such an
allocation. For instance, no known 64-bit platform can ever
serve a request for 263 bytes due to page-table limitations or
splitting the address space. However, some 32-bit and 16-bit
platforms may successfully serve a request for more than
<code>isize::MAX</code> bytes with things like Physical Address Extension. As
such, memory acquired directly from allocators or memory mapped
files may be too large to handle with this function.</p>
<p>Consider using <code>wrapping_offset</code> instead if these constraints are
difficult to satisfy. The only advantage of this method is that
it enables more aggressive compiler optimizations.</p>
</div><h4 id='method.wrapping_offset' class="method"><span id='wrapping_offset.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.wrapping_offset' class='fnname'>wrapping_offset</a>(self, count: <a class="type" href="../packed_simd/type.isizex8.html" title="type packed_simd::isizex8">isizex8</a>) -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#980-986' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Calculates the offset from a pointer using wrapping arithmetic.</p>
<p><code>count</code> is in units of <code>T</code>; e.g. a count of <code>3</code> represents a
pointer offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h1>
<p>The resulting pointer does not need to be in bounds, but it is
potentially hazardous to dereference (which requires unsafe).</p>
<p>Always use <code>.offset(count)</code> instead when possible, because offset
allows the compiler to optimize better.</p>
</div><h4 id='method.offset_from' class="method"><span id='offset_from.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub unsafe fn <a href='#method.offset_from' class='fnname'>offset_from</a>(self, origin: Self) -&gt; <a class="type" href="../packed_simd/type.isizex8.html" title="type packed_simd::isizex8">isizex8</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1029-1032' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Calculates the distance between two pointers.</p>
<p>The returned value is in units of <code>T</code>: the distance in bytes is
divided by <code>mem::size_of::&lt;T&gt;()</code>.</p>
<p>This function is the inverse of offset.</p>
<h1 id="safety-2" class="section-header"><a href="#safety-2">Safety</a></h1>
<p>If any of the following conditions are violated, the result is Undefined Behavior:</p>
<ul>
<li>
<p>Both the starting and other pointer must be either in bounds
or one byte past the end of the same allocated object.</p>
</li>
<li>
<p>The distance between the pointers, in bytes, cannot overflow an <code>isize</code>.</p>
</li>
<li>
<p>The distance between the pointers, in bytes, must be an exact
multiple of the size of <code>T</code>.</p>
</li>
<li>
<p>The distance being in bounds cannot rely on &quot;wrapping around&quot;
the address space.</p>
</li>
</ul>
<p>The compiler and standard library generally try to ensure
allocations never reach a size where an offset is a concern. For
instance, <code>Vec</code> and <code>Box</code> ensure they never allocate more than
<code>isize::MAX</code> bytes, so <code>ptr_into_vec.offset_from(vec.as_ptr())</code> is
always safe.</p>
<p>Most platforms fundamentally can't even construct such an
allocation. For instance, no known 64-bit platform can ever
serve a request for 263 bytes due to page-table limitations or
splitting the address space. However, some 32-bit and 16-bit
platforms may successfully serve a request for more than
<code>isize::MAX</code> bytes with things like Physical Address Extension. As
such, memory acquired directly from allocators or memory mapped
files may be too large to handle with this function.</p>
<p>Consider using wrapping_offset_from instead if these constraints
are difficult to satisfy. The only advantage of this method is
that it enables more aggressive compiler optimizations.</p>
</div><h4 id='method.wrapping_offset_from' class="method"><span id='wrapping_offset_from.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.wrapping_offset_from' class='fnname'>wrapping_offset_from</a>(self, origin: Self) -&gt; <a class="type" href="../packed_simd/type.isizex8.html" title="type packed_simd::isizex8">isizex8</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1048-1053' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Calculates the distance between two pointers.</p>
<p>The returned value is in units of <code>T</code>: the distance in bytes is
divided by <code>mem::size_of::&lt;T&gt;()</code>.</p>
<p>If the address different between the two pointers is not a
multiple of <code>mem::size_of::&lt;T&gt;()</code> then the result of the division
is rounded towards zero.</p>
<p>Though this method is safe for any two pointers, note that its
result will be mostly useless if the two pointers aren't into
the same allocated object, for example if they point to two
different local variables.</p>
</div><h4 id='method.add' class="method"><span id='add.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub unsafe fn <a href='#method.add' class='fnname'>add</a>(self, count: <a class="type" href="../packed_simd/type.usizex8.html" title="type packed_simd::usizex8">usizex8</a>) -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1094-1096' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Calculates the offset from a pointer (convenience for
<code>.offset(count as isize)</code>).</p>
<p><code>count</code> is in units of <code>T</code>; e.g. a count of 3 represents a
pointer offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-3" class="section-header"><a href="#safety-3">Safety</a></h1>
<p>If any of the following conditions are violated, the result is
Undefined Behavior:</p>
<ul>
<li>
<p>Both the starting and resulting pointer must be either in
bounds or one byte past the end of an allocated object.</p>
</li>
<li>
<p>The computed offset, in bytes, cannot overflow an <code>isize</code>.</p>
</li>
<li>
<p>The offset being in bounds cannot rely on &quot;wrapping around&quot;
the address space. That is, the infinite-precision sum must fit
in a <code>usize</code>.</p>
</li>
</ul>
<p>The compiler and standard library generally tries to ensure
allocations never reach a size where an offset is a concern. For
instance, <code>Vec</code> and <code>Box</code> ensure they never allocate more than
<code>isize::MAX</code> bytes, so <code>vec.as_ptr().add(vec.len())</code> is always safe.</p>
<p>Most platforms fundamentally can't even construct such an
allocation. For instance, no known 64-bit platform can ever
serve a request for 263 bytes due to page-table limitations or
splitting the address space. However, some 32-bit and 16-bit
platforms may successfully serve a request for more than
<code>isize::MAX</code> bytes with things like Physical Address Extension. As
such, memory acquired directly from allocators or memory mapped
files may be too large to handle with this function.</p>
<p>Consider using <code>wrapping_offset</code> instead if these constraints
are difficult to satisfy. The only advantage of this method is
that it enables more aggressive compiler optimizations.</p>
</div><h4 id='method.sub' class="method"><span id='sub.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub unsafe fn <a href='#method.sub' class='fnname'>sub</a>(self, count: <a class="type" href="../packed_simd/type.usizex8.html" title="type packed_simd::usizex8">usizex8</a>) -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1135-1139' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Calculates the offset from a pointer (convenience for
<code>.offset((count as isize).wrapping_neg())</code>).</p>
<p><code>count</code> is in units of T; e.g. a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-4" class="section-header"><a href="#safety-4">Safety</a></h1>
<p>If any of the following conditions are violated, the result is Undefined
Behavior:</p>
<ul>
<li>
<p>Both the starting and resulting pointer must be either in bounds or one
byte past the end of an allocated object.</p>
</li>
<li>
<p>The computed offset cannot exceed <code>isize::MAX</code> <strong>bytes</strong>.</p>
</li>
<li>
<p>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address
space. That is, the infinite-precision sum must fit in a usize.</p>
</li>
</ul>
<p>The compiler and standard library generally tries to ensure allocations
never reach a size where an offset is a concern. For instance, <code>Vec</code>
and <code>Box</code> ensure they never allocate more than <code>isize::MAX</code> bytes, so
<code>vec.as_ptr().add(vec.len()).sub(vec.len())</code> is always safe.</p>
<p>Most platforms fundamentally can't even construct such an allocation.
For instance, no known 64-bit platform can ever serve a request
for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.
However, some 32-bit and 16-bit platforms may successfully serve a request for
more than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or memory
mapped files <em>may</em> be too large to handle with this function.</p>
<p>Consider using <code>wrapping_offset</code> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
</div><h4 id='method.wrapping_add' class="method"><span id='wrapping_add.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.wrapping_add' class='fnname'>wrapping_add</a>(self, count: <a class="type" href="../packed_simd/type.usizex8.html" title="type packed_simd::usizex8">usizex8</a>) -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1155-1157' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Calculates the offset from a pointer using wrapping arithmetic.
(convenience for <code>.wrapping_offset(count as isize)</code>)</p>
<p><code>count</code> is in units of T; e.g. a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-5" class="section-header"><a href="#safety-5">Safety</a></h1>
<p>The resulting pointer does not need to be in bounds, but it is
potentially hazardous to dereference (which requires <code>unsafe</code>).</p>
<p>Always use <code>.add(count)</code> instead when possible, because <code>add</code>
allows the compiler to optimize better.</p>
</div><h4 id='method.wrapping_sub' class="method"><span id='wrapping_sub.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.wrapping_sub' class='fnname'>wrapping_sub</a>(self, count: <a class="type" href="../packed_simd/type.usizex8.html" title="type packed_simd::usizex8">usizex8</a>) -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1173-1176' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Calculates the offset from a pointer using wrapping arithmetic.
(convenience for <code>.wrapping_offset((count as isize).wrapping_sub())</code>)</p>
<p><code>count</code> is in units of T; e.g. a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-6" class="section-header"><a href="#safety-6">Safety</a></h1>
<p>The resulting pointer does not need to be in bounds, but it is
potentially hazardous to dereference (which requires <code>unsafe</code>).</p>
<p>Always use <code>.sub(count)</code> instead when possible, because <code>sub</code>
allows the compiler to optimize better.</p>
</div></div><h3 id='impl-5' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="type" href="../packed_simd/type.mptrx8.html" title="type packed_simd::mptrx8">mptrx8</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;[T; 8]: SimdArray,&nbsp;</span></code><a href='#impl-5' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/ptr/gather_scatter.rs.html#5-30' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.read' class="method"><span id='read.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub unsafe fn <a href='#method.read' class='fnname'>read</a>&lt;M&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;mask: <a class="struct" href="../packed_simd/struct.Simd.html" title="struct packed_simd::Simd">Simd</a>&lt;[M; 8]&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;value: <a class="struct" href="../packed_simd/struct.Simd.html" title="struct packed_simd::Simd">Simd</a>&lt;[T; 8]&gt;<br>) -&gt; <a class="struct" href="../packed_simd/struct.Simd.html" title="struct packed_simd::Simd">Simd</a>&lt;[T; 8]&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: Mask,<br>&nbsp;&nbsp;&nbsp;&nbsp;[M; 8]: SimdArray,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/ptr/gather_scatter.rs.html#22-29' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Reads selected vector elements from memory.</p>
<p>Instantiates a new vector by reading the values from <code>self</code> for
those lanes whose <code>mask</code> is <code>true</code>, and using the elements of
<code>value</code> otherwise.</p>
<p>No memory is accessed for those lanes of <code>self</code> whose <code>mask</code> is
<code>false</code>.</p>
<h1 id="safety-7" class="section-header"><a href="#safety-7">Safety</a></h1>
<p>This method is unsafe because it dereferences raw pointers. The
pointers must be aligned to <code>mem::align_of::&lt;T&gt;()</code>.</p>
</div></div><h3 id='impl-6' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="type" href="../packed_simd/type.mptrx8.html" title="type packed_simd::mptrx8">mptrx8</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;[T; 8]: SimdArray,&nbsp;</span></code><a href='#impl-6' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/ptr/gather_scatter.rs.html#89-135' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.write' class="method"><span id='write.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub unsafe fn <a href='#method.write' class='fnname'>write</a>&lt;M&gt;(self, mask: <a class="struct" href="../packed_simd/struct.Simd.html" title="struct packed_simd::Simd">Simd</a>&lt;[M; 8]&gt;, value: <a class="struct" href="../packed_simd/struct.Simd.html" title="struct packed_simd::Simd">Simd</a>&lt;[T; 8]&gt;) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: Mask,<br>&nbsp;&nbsp;&nbsp;&nbsp;[M; 8]: SimdArray,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/ptr/gather_scatter.rs.html#109-134' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Writes selected vector elements to memory.</p>
<p>Writes the lanes of <code>values</code> for which the mask is <code>true</code> to
their corresponding memory addresses in <code>self</code>.</p>
<p>No memory is accessed for those lanes of <code>self</code> whose <code>mask</code> is
<code>false</code>.</p>
<p>Overlapping memory addresses of <code>self</code> are written to in order
from the lest-significant to the most-significant element.</p>
<h1 id="safety-8" class="section-header"><a href="#safety-8">Safety</a></h1>
<p>This method is unsafe because it dereferences raw pointers. The
pointers must be aligned to <code>mem::align_of::&lt;T&gt;()</code>.</p>
</div></div><h2 id='implementations' class='small-section-header'>Trait Implementations<a href='#implementations' class='anchor'></a></h2><div id='implementations-list'><h3 id='impl-Debug' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="type" href="../packed_simd/type.mptrx8.html" title="type packed_simd::mptrx8">mptrx8</a>&lt;T&gt;</code><a href='#impl-Debug' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#185-200' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.fmt' class="method"><span id='fmt.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#188-199' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id='impl-Default' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="type" href="../packed_simd/type.mptrx8.html" title="type packed_simd::mptrx8">mptrx8</a>&lt;T&gt;</code><a href='#impl-Default' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#237-243' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.default' class="method"><span id='default.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default' class='fnname'>default</a>() -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#239-242' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns the &quot;default value&quot; for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></div><h3 id='impl-PartialEq%3Cmptrx8%3CT%3E%3E' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="type" href="../packed_simd/type.mptrx8.html" title="type packed_simd::mptrx8">mptrx8</a>&lt;T&gt;&gt; for <a class="type" href="../packed_simd/type.mptrx8.html" title="type packed_simd::mptrx8">mptrx8</a>&lt;T&gt;</code><a href='#impl-PartialEq%3Cmptrx8%3CT%3E%3E' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#375-384' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.eq-1' class="method"><span id='eq.v-1' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, other: &amp;Self) -&gt; bool</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#377-379' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id='method.ne-1' class="method"><span id='ne.v-1' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;Self) -&gt; bool</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#381-383' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id='impl-Eq' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="type" href="../packed_simd/type.mptrx8.html" title="type packed_simd::mptrx8">mptrx8</a>&lt;T&gt;</code><a href='#impl-Eq' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#430' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'></div><h3 id='impl-From%3C%5B*mut%20T%3B%208%5D%3E' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;[*mut T; 8]&gt; for <a class="type" href="../packed_simd/type.mptrx8.html" title="type packed_simd::mptrx8">mptrx8</a>&lt;T&gt;</code><a href='#impl-From%3C%5B*mut%20T%3B%208%5D%3E' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#448-462' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.from' class="method"><span id='from.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(array: [*mut T; 8]) -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#450-461' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Into%3C%5B*mut%20T%3B%208%5D%3E' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;[*mut T; 8]&gt; for <a class="type" href="../packed_simd/type.mptrx8.html" title="type packed_simd::mptrx8">mptrx8</a>&lt;T&gt;</code><a href='#impl-Into%3C%5B*mut%20T%3B%208%5D%3E' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#463-477' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.into' class="method"><span id='into.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; [*mut T; 8]</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#465-476' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Hash' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="type" href="../packed_simd/type.mptrx8.html" title="type packed_simd::mptrx8">mptrx8</a>&lt;T&gt;</code><a href='#impl-Hash' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#882-888' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.hash' class="method"><span id='hash.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash' class='fnname'>hash</a>&lt;H:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: &amp;mut H)</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#884-887' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Feeds this value into the given [<code>Hasher</code>]. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div><h4 id='method.hash_slice' class="method"><span id='hash_slice.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice' class='fnname'>hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: &amp;mut H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.3.0'>1.3.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/hash/mod.rs.html#203-209' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Feeds a slice of this type into the given [<code>Hasher</code>]. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "packed_simd";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>